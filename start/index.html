<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
	<title>first</title>
	<script src="pixi.min.js"></script>
	<style>*{padding:0;margin:0;}</style>
</head>
<body>
	<script>
		var type = "WebGL";
		if(!PIXI.utils.isWebGLSupported()){
			type = "canvas";
		}
		PIXI.utils.sayHello(type);
		//简短命名
		var Container = PIXI.Container,
		    autoDetectRenderer = PIXI.autoDetectRenderer,
		    loader = PIXI.loader,
		    resources = PIXI.loader.resources,
		    TextureCache = PIXI.TextureCache,
		    Rectangle = PIXI.Rectangle,
		    Sprite = PIXI.Sprite,
		    ParticleContainer = PIXI.ParticleContainer,
		    Text = PIXI.text;
		var renderer = PIXI.autoDetectRenderer(256,256);
		document.body.appendChild(renderer.view);
		var stage = new PIXI.Container();
		//pixi内置loader对象加载图片
		PIXI.loader.add(["images/sprite.png","images/sprite2.png","images/tileset.png"]).on("progress",loadProgress).load(setup);
		function loadProgress(loader, res){
			console.log("loading:" + res.url);
			console.log("progress:" + loader.progress + "%");
			console.log(res.name);
		}
		//在图片加载完成后以下函数执行
		var zb,state,rocket;
		function setup(){
			zb = new Sprite(
				PIXI.loader.resources["images/sprite.png"].texture
			);

			var texture = TextureCache["images/tileset.png"];
			var rectangle = new Rectangle(192,128,64,64);
			texture.frame = rectangle;
			rocket = new Sprite(texture);
			rocket.position.set(10,90);
			//初始化精灵的位置
			// zb.position.set(150,78+zb.height/2);
			zb.position.set(78,78);
			zb.vx = 0;//移动速度
			zb.vy = 0;
			// zb.scale.set(1,1);
			zb.rotation = 0;
			// zb.anchor.set(0.5,0.5);
			//捕捉键盘方向键
			var left = keyboard(37),
				up = keyboard(38),
				right = keyboard(39),
				down = keyboard(40);
			left.press = function(){
				zb.vx = -1;
				zb.vy = 0;
			}
			left.release = function(){
				if(!right.isDown && zb.vy === 0){
					zb.vx = 0;
				}
			}
			up.press = function(){
				zb.vy = -1;
				zb.vx = 0;
			}
			up.release = function(){
				if(!down.isDown && zb.vx === 0){
					zb.vy = 0;
				}
			}
			right.press = function(){
				zb.vx = 1;
				zb.vy = 0;
			}
			right.release = function(){
				if(!left.isDown && zb.vy === 0){
					zb.vx = 0;
				}
			}
			down.press = function(){
				zb.vx = 0;
				zb.vy = 1;
			}
			down.release = function(){
				if(!up.isDown && zb.vx === 0){
					zb.vy = 0;
				}
			}
			stage.addChild(zb);
			stage.addChild(rocket);
			state = play;
			gameLoop(zb);
		}
		function gameLoop(){
			if(zb.x == 200){
				return false;
			}
			requestAnimationFrame(gameLoop);
			state();
			renderer.render(stage);
		}
		function play(){
			zb.x += zb.vx;
			zb.y += zb.vy;
			
			if(hitTestRectangle(zb,rocket)){
				console.log("aaa");
			}
		}
		function keyboard(keyCode){
			var key = {};
			key.code = keyCode;
			key.isDown = false;
			key.isUp = true;
			key.press = undefined;
			key.release = undefined;

			key.downHandler = function(event){
				if(event.keyCode === key.code){
					if(key.isUp && key.press) key.press();
					key.isDown = true;
					key.isUp = false;
				}
				event.preventDefault();
			}
			key.upHandler = function(event){
				if(event.keyCode === key.code){
					if(key.isDown && key.release) key.release();
					key.isDown = false;
					key.isUp = true;
				}
				event.preventDefault();
			}
			window.addEventListener("keydown",key.downHandler.bind(key),false)
			window.addEventListener("keyup",key.upHandler.bind(key),false)
			return key;
		}
		//碰撞判断函数
		function hitTestRectangle(r1, r2) {
		    //定义计算时需要使用到的变量
		    var hit, combinedHalfWidths, combinedHalfHeight, vx, vy;

		    //hit用于定义是否发生碰撞
		    var hit = false;

		    //计算两个精灵的中心点位置
		    r1.centerX = r1.x + r1.width / 2;
		    r1.centerY = r1.y + r1.height / 2;
		    r2.centerX = r2.x + r2.width / 2;
		    r2.centerY = r2.y + r2.height / 2;

		    //计算两个精灵宽和高的二分之一
		    r1.halfWidth = r1.width / 2;
		    r1.halfHeight = r1.height / 2;
		    r2.halfWidth = r2.width / 2;
		    r2.halfHeight = r2.height / 2;

		    //计算两个精灵中心点的距离
		    vx = r1.centerX - r2.centerX;
		    vy = r1.centerY - r2.centerY;

		    //计算两个精灵宽和高各自的和
		    combinedHalfWidths = r1.halfWidth + r2.halfWidth;
		    combinedHalfHeights = r1.halfHeight + r2.halfHeight;

		    //检测x方向上的碰撞
		    if(Math.abs(vx) < combinedHalfWidths) {
		        //碰撞可能发生，检测y方向上是否发生碰撞
		        if(Math.abs(vy) < combinedHalfHeights) {
		            //肯定发生了碰撞
		            hit = true;
		        } else {
		            //y方向上没有发生碰撞
		            hit = false;
		        }
		    } else {
		        //x方向上没有发生碰撞
		        hit = false;
		    }

		    //“hit”会返回“true”或“false”
		    return hit;
		};
		renderer.view.style.position = "absolute";
		renderer.view.style.display = "block";
		renderer.autoResize = true;
	</script>
</body>
</html>